using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Schema;
using Frank.UblSharp.Generator.Extensions;

namespace Frank.UblSharp.Generator
{
    public class CodeNamespaceProvider
    {
        private const string NamespaceHeader = @"------------------------------------------------------------------------------
 <auto-generated>
     This code was generated by a tool.

     Manual changes to this file will be overwritten if the code is regenerated.

 </auto-generated>
------------------------------------------------------------------------------";
        private readonly XmlSchemaSet _schemaSet;
        private readonly UblGeneratorOptions _options;

        private readonly Dictionary<string, string> _xmlToCsNamespaces = new Dictionary<string, string>
        {
            { Namespaces.BaseDocument, "" },
            { Namespaces.Cac, "CommonAggregateComponents" },
            { Namespaces.Cbc, "UnqualifiedDataTypes" }, // Use Udt instead of Cct (the types in Cbc are refactored out)
            { Namespaces.Cct, "CoreComponentTypes" },
            { Namespaces.Cec, "CommonExtensionComponents" },
            { Namespaces.Csc, "CommonSignatureComponents" },
            { Namespaces.Qdt, "QualifiedDataTypes" }, // There are no Qdt's in UBL
            { Namespaces.Sac, "SignatureAggregateComponents" },
            { Namespaces.Sbc, "" },
            { Namespaces.Udt, "UnqualifiedDataTypes" },
            { Namespaces.Xades132, "Xades" },
            { Namespaces.Xades141, "Xades" },
            { Namespaces.Xmldsig, "XmlDigitalSignature" }            
        };

        // Reverses imports (for cross namespace XmlIncludeAttribute usage)
        private readonly Dictionary<string, string[]> _xmlToCsNamespacesReverse = new Dictionary<string, string[]>()
        {
            { Namespaces.Cct, new[] { Namespaces.Udt } }
        };

        public CodeNamespaceProvider(XmlSchemaSet schemaSet, UblGeneratorOptions options)
        {
            _schemaSet = schemaSet;
            _options = options;

            var mainSchemas = schemaSet.Schemas().Cast<XmlSchema>().Where(x => x.SourceUri.Contains("maindoc"));
            foreach (var schema in mainSchemas)
            {
                var targetNamespace = schema.TargetNamespace;
                _xmlToCsNamespaces[targetNamespace] = string.Empty;
            }

            foreach (var mapping in options.XmlToCsNamespaceMapping)
            {
                _xmlToCsNamespaces[mapping.Key] = mapping.Value;
            }
        }

        public CodeNamespace CreateCodeNamespace(XmlSchema schema)
        {
            string xmlNamespace = schema.TargetNamespace;
            var csScopeName = "";

            if (_xmlToCsNamespaces.ContainsKey(xmlNamespace))
            {
                csScopeName = _xmlToCsNamespaces[xmlNamespace];
            }

            if (!string.IsNullOrEmpty(csScopeName))
            {
                csScopeName = "." + csScopeName;
            }

            csScopeName = _options.Namespace + csScopeName;

            var codeNs = new CodeNamespace(csScopeName);
            codeNs.UserData[CodeTypeMemberExtensions.XmlSchemaKey] = schema;

            codeNs.Comments.Add(new CodeCommentStatement(new CodeComment(NamespaceHeader)));

            if (xmlNamespace.Equals(Namespaces.BaseDocument))
            {
                return codeNs;
            }

            if (_options.UblSharpNamespace != _options.Namespace)
            {
                codeNs.Imports.Add(new CodeNamespaceImport(_options.UblSharpNamespace));
            }

            foreach (var import in schema.Includes.OfType<XmlSchemaImport>())
            {
                if (_xmlToCsNamespaces.ContainsKey(import.Namespace))
                {
                    var importNs = _xmlToCsNamespaces[import.Namespace];
                    if (string.IsNullOrEmpty(importNs))
                    {
                        continue;
                    }

                    importNs = _options.UblSharpNamespace + "." + importNs;

                    codeNs.Imports.Add(new CodeNamespaceImport(importNs));
                }
            }

            if (_xmlToCsNamespacesReverse.TryGetValue(schema.TargetNamespace, out var reverseNamespaces))
            {
                foreach (var ns in reverseNamespaces)
                {
                    var importNs = _xmlToCsNamespaces[ns];
                    if (string.IsNullOrEmpty(importNs))
                    {
                        continue;
                    }

                    importNs = _options.UblSharpNamespace + "." + importNs;

                    codeNs.Imports.Add(new CodeNamespaceImport(importNs));
                }
            }

            return codeNs;
        }

        public string GetNamespaceFolderName(XmlSchema schema)
        {
            if (schema.IsMaindocSchema() || schema.SourceUri.Contains("BaseDocument"))
            {
                // This is only for 'UblSharp' base library, else it goes to the root
                return "maindoc";
            }

            string ns;
            if (_xmlToCsNamespaces.TryGetValue(schema.TargetNamespace, out ns))
                return ns;

            return string.Empty;
            // throw new InvalidOperationException("Cannot find target folder for namespace: " + schema.TargetNamespace);
        }
    }
}
